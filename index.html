<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centauri Carbon Bed Mesh Visualizer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #ffffff;
            font-size: 2em;
        }

        .upload-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #4a4a4a;
            transition: border-color 0.3s;
        }

        .upload-section:hover {
            border-color: #6a6a6a;
        }

        .instructions {
            text-align: left;
            margin-bottom: 25px;
            padding: 20px;
            background: #3a3a3a;
            border-radius: 8px;
        }

        .instructions h3 {
            color: #ffffff;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .instructions ol {
            margin-left: 20px;
            line-height: 1.8;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .gcode-link {
            color: #4da6ff;
            text-decoration: none;
            font-weight: bold;
            padding: 2px 6px;
            background: rgba(77, 166, 255, 0.1);
            border-radius: 3px;
            transition: background 0.3s;
        }

        .gcode-link:hover {
            background: rgba(77, 166, 255, 0.2);
            text-decoration: underline;
        }

        .file-input-wrapper {
            position: relative;
            display: flex;
            width: 100%;
            justify-content: center;
        }

        input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: inline-block;
            padding: 12px 30px;
            background: #0066cc;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s;
        }

        .file-input-label:hover {
            background: #0052a3;
        }

        .file-name {
            margin-top: 15px;
            color: #aaa;
            font-size: 14px;
            text-align: center;
        }

        .info-section {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }

        .info-section.active {
            display: block;
        }

        .profile-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .profile-btn {
            padding: 10px 20px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .profile-btn:hover {
            border-color: #6a6a6a;
        }

        .profile-btn.active {
            background: #0066cc;
            border-color: #0066cc;
            color: white;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 180px), 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #3a3a3a;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #0066cc;
            min-width: 0;
            overflow: hidden;
        }

        .stat-label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #fff;
            word-break: break-word;
        }

        #plotParent {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 20px;
            display: none;
        }

        #plotParent:has(#plotContainer.active) {
            display: block;
        }

        #plotContainer {
            min-height: 600px;
            visibility: hidden;
            height: 0;
            overflow: hidden;
        }

        #plotContainer.active {
            visibility: visible;
            height: auto;
        }

        .error {
            background: #4a2a2a;
            border: 1px solid #8a3a3a;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 20px;
            color: #ffaaaa;
        }

        /* ---- PATCH: controls styled to match, but NOT using .profile-btn ---- */
        .control-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(100%, 280px), 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-btn {
            padding: 10px 20px;
            background: #3a3a3a;
            border: 2px solid #4a4a4a;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s;
        }
        .control-btn:hover { border-color:#6a6a6a; }

        .control-btn.primary {
            background:#0066cc;
            border-color:#0066cc;
            color:#fff;
        }
        .control-btn.primary:hover { background:#0052a3; border-color:#0052a3; }

        .control-btn.warn {
            background:#8a3a3a;
            border-color:#8a3a3a;
            color:#fff;
        }
        .control-btn.warn:hover { background:#a04444; border-color:#a04444; }

        .control-btn-row {
            display:flex;
            gap:10px;
            flex-wrap:wrap;
            margin-top:10px;
        }

        .control-input {
            width: 100%;
            margin-top: 8px;
        }

        .control-select {
            width:100%;
            margin-top:8px;
            padding: 8px 10px;
            border-radius: 6px;
            border: 2px solid #4a4a4a;
            background: #2f2f2f;
            color: #e0e0e0;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            .upload-section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Centauri Carbon Bed Mesh Visualizer</h1>

        <div class="upload-section">
            <div class="instructions">
                <h3>Instructions:</h3>
                <ol>
                    <li>Plug a USB drive into your PC</li>
                    <li>Copy <a href="#" class="gcode-link" id="gcodeDownload">M8803.gcode</a> to your USB drive</li>
                    <li>Eject the USB drive from your PC</li>
                    <li>Plug the same USB drive into your Centauri Carbon</li>
                    <li>Go to the files menu and print M8803.gcode</li>
                    <li>Unplug the USB drive after clicking finish</li>
                    <li>Plug the same USB drive back into your computer</li>
                    <li>Upload printer.cfg from the USB drive to the website</li>
                </ol>
            </div>
            <div class="file-input-wrapper">
                <input type="file" id="fileInput" accept=".cfg,.txt">
                <label for="fileInput" class="file-input-label">Choose printer.cfg file</label>
            </div>
            <div class="file-name" id="fileName"></div>
        </div>

        <div id="errorContainer"></div>

        <div class="info-section" id="infoSection">
            <div class="profile-selector" id="profileSelector"></div>

            <!-- ---- PATCH: controls (kept in the same card language) ---- -->
            <div class="control-row" id="controlRow" style="display:none;">
                <div class="stat-card" style="border-left-color:#4da6ff;">
                    <div class="stat-label">Visual Z Span</div>
                    <input class="control-input" type="range" id="zSpanSlider" min="0.10" max="5.00" step="0.05" value="1.00">
                    <div class="stat-value" id="zSpanValue" style="font-size:16px;">1.00 mm</div>

                    <div class="control-btn-row">
                        <button class="control-btn primary" id="autoZBtn" type="button">AUTO</button>
                        <button class="control-btn" id="resetViewBtn" type="button">Reset View</button>
                        <button class="control-btn" id="exportCsvBtn" type="button">Export CSV</button>
                    </div>

                    <div class="stat-label" style="margin-top:10px; text-transform:none; letter-spacing:0;">
                        AUTO sets visual span to true flatness. Slider caps at 5.00 mm.
                    </div>
                </div>

                <div class="stat-card" style="border-left-color:#ffaa00;">
                    <div class="stat-label">Saved Meshes</div>

                    <select class="control-select" id="savedMeshSelect"></select>

                    <div class="control-btn-row">
                        <button class="control-btn primary" id="saveMeshBtn" type="button">Save</button>
                        <button class="control-btn" id="loadMeshBtn" type="button">Load</button>
                        <button class="control-btn" id="renameMeshBtn" type="button">Rename</button>
                        <button class="control-btn warn" id="deleteMeshBtn" type="button">Delete</button>
                        <button class="control-btn warn" id="clearAllBtn" type="button">Clear All</button>
                    </div>

                    <div class="stat-label" style="margin-top:10px; text-transform:none; letter-spacing:0;">
                        Delta card uses the selected saved mesh as reference.
                    </div>
                </div>
            </div>

            <div class="stats" id="statsContainer"></div>
        </div>

        <div id="plotParent">
            <div id="plotContainer"></div>
        </div>
    </div>

    <script>
        const profiles = {
            'standard': ['besh_profile_standard_default', 'Side A'],
            'enhancement': ['besh_profile_enhancement_default', 'Side B'],
            /*'standard_secondary': ['besh_profile_standard_1', 'Side A (Secondary)'],
            'enhancement_secondary': ['besh_profile_enhancement_1', 'Side B (Secondary)']*/
        };

        let parsedProfiles = {};
        let currentProfile = null;

        // ---- PATCH: maintain a "current mesh" handle so saved meshes can load without breaking profile UI
        let currentMesh = null;
        let currentMeshLabel = '';

        // ---- PATCH: visual Z span (mm)
        let visualZSpan = 1.00; // mm, 0.10..5.00

        // ---- PATCH: front-facing view (looking at printer from the front)
        const FRONT_CAMERA = {
            eye: { x: 0, y: -2.0, z: 1.2 },
            center: { x: 0, y: 0, z: 0 },
            up: { x: 0, y: 0, z: 1 }
        };

        // ---- PATCH: localStorage saved meshes
        const STORAGE_KEY = 'cc_saved_meshes_v3';
        let savedMeshes = [];
        try {
            savedMeshes = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') || [];
        } catch (e) {
            savedMeshes = [];
        }

        // Create downloadable M8803.gcode file (original)
        document.getElementById('gcodeDownload').addEventListener('click', function(e) {
            e.preventDefault();
            const blob = new Blob(['M8803'], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'M8803.gcode';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        function showError(message) {
            const errorContainer = document.getElementById('errorContainer');
            errorContainer.innerHTML = `<div class="error">${message}</div>`;
        }

        function clearError() {
            document.getElementById('errorContainer').innerHTML = '';
        }

        function persistSavedMeshes() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(savedMeshes));
        }

        function computeFlatness(points2d) {
            const flat = points2d.flat();
            return Math.max(...flat) - Math.min(...flat);
        }

        function mean(arr) {
            let s = 0;
            for (const v of arr) s += v;
            return arr.length ? (s / arr.length) : 0;
        }

        // ---- PATCH: scale mesh visually so total shown span is targetSpan mm
        function scalePointsToZSpan(points2d, targetSpan) {
            const flat = points2d.flat();
            const minZ = Math.min(...flat);
            const maxZ = Math.max(...flat);
            const span = maxZ - minZ;

            if (span <= 0) return points2d;

            const m = mean(flat);
            const scale = targetSpan / span;
            return points2d.map(row => row.map(z => m + (z - m) * scale));
        }

        function exportMeshCSV(mesh, label) {
            const { points, configs } = mesh;
            const rows = [];
            rows.push(`# ${label || 'Bed Mesh'}`);
            rows.push('x_mm,y_mm,z_mm');

            for (let y = 0; y < configs.y_count; y++) {
                for (let x = 0; x < configs.x_count; x++) {
                    const xPos = configs.min_x + (configs.max_x - configs.min_x) * x / (configs.x_count - 1);
                    const yPos = configs.min_y + (configs.max_y - configs.min_y) * y / (configs.y_count - 1);
                    rows.push(`${xPos.toFixed(3)},${yPos.toFixed(3)},${points[y][x].toFixed(6)}`);
                }
            }

            const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = (label || 'bed_mesh').replace(/[^\w\-]+/g,'_').toLowerCase() + '.csv';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function renderSavedDropdown() {
            const sel = document.getElementById('savedMeshSelect');
            sel.innerHTML = '';

            const optNone = document.createElement('option');
            optNone.value = '__none__';
            optNone.textContent = 'Delta reference: (none)';
            sel.appendChild(optNone);

            if (savedMeshes.length) {
                const optLast = document.createElement('option');
                optLast.value = '__last__';
                optLast.textContent = `Delta reference: LAST saved (${savedMeshes[savedMeshes.length - 1].label})`;
                sel.appendChild(optLast);
            }

            savedMeshes.forEach((m, i) => {
                const o = document.createElement('option');
                o.value = String(i);
                o.textContent = m.label;
                sel.appendChild(o);
            });

            // ✅ Auto-select last saved as delta reference on page load (and after render)
            sel.value = savedMeshes.length ? '__last__' : '__none__';
        }

        function getSelectedSavedIndex() {
            const sel = document.getElementById('savedMeshSelect');
            const v = sel.value;

            if (v === '__none__') return null;
            if (v === '__last__') return savedMeshes.length ? (savedMeshes.length - 1) : null;

            const idx = parseInt(v, 10);
            return Number.isFinite(idx) ? idx : null;
        }

        function parseProfile(configContent, sectionName) {
            // ORIGINAL parser, unchanged
            let sectionPattern = new RegExp(`\\[${sectionName}\\]([\\s\\S]*?)(?=\\n\\[|$)`, 'i');
            let sectionMatch = configContent.match(sectionPattern);

            if (!sectionMatch) {
                return null;
            }

            const sectionStr = sectionMatch[1];

            const meshPointsMatch = sectionStr.match(/points\s*:\s*([-\d.,\s]+)/i);
            if (!meshPointsMatch) {
                return null;
            }

            const meshPointsStr = meshPointsMatch[1];

            function extractMeshConfig(key, defaultValue) {
                const match = sectionStr.match(new RegExp(`${key}\\s*:\\s*([\\d.]+)`, 'i'));
                return match ? parseFloat(match[1]) : defaultValue;
            }

            const meshConfigs = {
                min_x: extractMeshConfig('min_x', 20),
                max_x: extractMeshConfig('max_x', 246),
                min_y: extractMeshConfig('min_y', 20),
                max_y: extractMeshConfig('max_y', 246),
                x_count: parseInt(extractMeshConfig('x_count', 11)),
                y_count: parseInt(extractMeshConfig('y_count', 11))
            };

            const meshPoints = meshPointsStr.split(',')
                .map(p => p.trim())
                .filter(p => p.length > 0)
                .map(p => parseFloat(p));

            const expectedPoints = meshConfigs.x_count * meshConfigs.y_count;
            if (meshPoints.length !== expectedPoints) {
                console.warn(`Expected ${expectedPoints} values in ${sectionName}, found ${meshPoints.length}`);
                return null;
            }

            const points = [];
            for (let i = 0; i < meshConfigs.y_count; i++) {
                points.push(meshPoints.slice(i * meshConfigs.x_count, (i + 1) * meshConfigs.x_count));
            }

            return {
                points: points,
                configs: meshConfigs
            };
        }

        function createPlot(profileKey, mesh, labelOverride) {
            const rawPoints = mesh.points;
            const configs = mesh.configs;

            // Create coordinate arrays (original)
            const xCoords = [];
            const yCoords = [];
            for (let i = 0; i < configs.x_count; i++) {
                xCoords.push(configs.min_x + (configs.max_x - configs.min_x) * i / (configs.x_count - 1));
            }
            for (let i = 0; i < configs.y_count; i++) {
                yCoords.push(configs.min_y + (configs.max_y - configs.min_y) * i / (configs.y_count - 1));
            }

            // Stats (true)
            const flatPoints = rawPoints.flat();
            const minZ = Math.min(...flatPoints);
            const maxZ = Math.max(...flatPoints);
            const flatnessDev = maxZ - minZ;

            // PATCH: delta vs selected reference
            let deltaCard = '';
            const refIdx = getSelectedSavedIndex();
            if (refIdx !== null && savedMeshes[refIdx] && typeof savedMeshes[refIdx].flatness === 'number') {
                const ref = savedMeshes[refIdx];
                const d = flatnessDev - ref.flatness;
                deltaCard = `
                    <div class="stat-card">
                        <div class="stat-label">Δ Flatness vs Reference</div>
                        <div class="stat-value">${d.toFixed(5)} mm</div>
                    </div>
                `;
            }

            // Update stats display (original + optional delta)
            document.getElementById('statsContainer').innerHTML = `
                <div class="stat-card">
                    <div class="stat-label">Min Height</div>
                    <div class="stat-value">${minZ.toFixed(5)} mm</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Max Height</div>
                    <div class="stat-value">${maxZ.toFixed(5)} mm</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Flatness Deviation</div>
                    <div class="stat-value">${flatnessDev.toFixed(5)} mm</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Grid Size</div>
                    <div class="stat-value">${configs.x_count} × ${configs.y_count}</div>
                </div>
                ${deltaCard}
            `;

            // Create z=0 plane (original)
            const zeroPlane = Array(2).fill(null).map(() => Array(2).fill(0));
            const planeX = [configs.min_x, configs.max_x];
            const planeY = [configs.min_y, configs.max_y];

            // PATCH: visual scaling to target Z span
            const shownPoints = scalePointsToZSpan(rawPoints, visualZSpan);

            const data = [
                {
                    type: 'surface',
                    x: xCoords,
                    y: yCoords,
                    z: shownPoints,
                    colorscale: 'RdBu',
                    reversescale: false,
                    colorbar: {
                        title: 'Height (mm)',
                        titleside: 'right'
                    },
                    name: 'Bed Mesh',
                    customdata: rawPoints,
                    hovertemplate:
                        'X: %{x:.1f} mm<br>' +
                        'Y: %{y:.1f} mm<br>' +
                        'Z true: %{customdata:.5f} mm<br>' +
                        'Z shown: %{z:.5f} mm' +
                        '<extra></extra>'
                },
                {
                    type: 'surface',
                    x: planeX,
                    y: planeY,
                    z: zeroPlane,
                    colorscale: [[0, 'rgba(100, 255, 100, 0.3)'], [1, 'rgba(100, 255, 100, 0.3)']],
                    showscale: false,
                    name: 'Z=0 Reference',
                    hovertemplate: 'X: %{x:.1f} mm<br>Y: %{y:.1f} mm<br>Z: 0.000 mm<extra></extra>'
                }
            ];

            const displayName = labelOverride || profiles[profileKey]?.[1] || 'Bed Mesh';

            const layout = {
                title: {
                    text: `Bed Mesh: ${displayName}<br><sub>Flatness deviation (true): ${flatnessDev.toFixed(3)} mm • Visual span: ${visualZSpan.toFixed(2)} mm</sub>`,
                    font: { color: '#e0e0e0' }
                },
                scene: {
                    xaxis: { title: 'X (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    yaxis: { title: 'Y (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    zaxis: { title: 'Height (mm)', color: '#e0e0e0', gridcolor: '#4a4a4a' },
                    bgcolor: '#2a2a2a',
                    camera: {
                        eye: { x: 1.5, y: 1.5, z: 1.3 }
                    }
                },
                paper_bgcolor: '#2a2a2a',
                plot_bgcolor: '#2a2a2a',
                font: { color: '#e0e0e0' },
                margin: { l: 0, r: 0, t: 80, b: 0 }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                displaylogo: false
            };

            // Preserve camera (original behavior) OR use front camera on first render
            const plotContainer = document.getElementById('plotContainer');
            if (plotContainer.data && plotContainer.layout && plotContainer.layout.scene) {
                layout.scene.camera = plotContainer.layout.scene.camera;
            } else {
                layout.scene.camera = FRONT_CAMERA;
            }

            Plotly.react('plotContainer', data, layout, config);

            // Ensure plot parent visible even if :has unsupported
            document.getElementById('plotParent').style.display = 'block';

            setTimeout(() => {
                Plotly.Plots.resize('plotContainer');
            }, 100);
        }

        function displayProfile(profileKey) {
            currentProfile = profileKey;
            const mesh = parsedProfiles[profileKey];

            // IMPORTANT PATCH: only toggle active state for REAL profile buttons
            document.querySelectorAll('#profileSelector .profile-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.profile === profileKey);
            });

            // Track current mesh
            currentMesh = mesh;
            currentMeshLabel = profiles[profileKey][1];

            createPlot(profileKey, mesh, currentMeshLabel);
            document.getElementById('plotContainer').classList.add('active');
        }

        function displaySavedMesh(entry) {
            // Clear active profile highlight
            document.querySelectorAll('#profileSelector .profile-btn').forEach(btn => btn.classList.remove('active'));

            currentProfile = '__saved__';
            currentMesh = entry.mesh;
            currentMeshLabel = `Saved: ${entry.label}`;

            createPlot('__saved__', currentMesh, currentMeshLabel);
            document.getElementById('plotContainer').classList.add('active');
        }

        function processFile(content) {
            clearError();
            parsedProfiles = {};

            for (const [key, [sectionName, displayName]] of Object.entries(profiles)) {
                const mesh = parseProfile(content, sectionName);
                if (mesh) {
                    parsedProfiles[key] = mesh;
                }
            }

            if (Object.keys(parsedProfiles).length === 0) {
                showError('No valid bed mesh profiles found in the config file. Looking for: ' +
                    Object.values(profiles).map(p => p[0]).join(', '));
                document.getElementById('infoSection').classList.remove('active');
                document.getElementById('plotContainer').classList.remove('active');
                document.getElementById('controlRow').style.display = 'none';
                return;
            }

            const profileSelector = document.getElementById('profileSelector');
            profileSelector.innerHTML = '';

            for (const [key, mesh] of Object.entries(parsedProfiles)) {
                const btn = document.createElement('button');
                btn.className = 'profile-btn';
                btn.textContent = profiles[key][1];
                btn.dataset.profile = key;
                btn.onclick = () => displayProfile(key);
                profileSelector.appendChild(btn);
            }

            document.getElementById('infoSection').classList.add('active');
            document.getElementById('controlRow').style.display = 'grid';

            // Show first profile by default
            const firstProfile = Object.keys(parsedProfiles)[0];
            displayProfile(firstProfile);
        }

        function rerenderIfReady() {
            if (currentMesh) {
                createPlot(currentProfile || 'standard', currentMesh, currentMeshLabel);
            }
        }

        // File upload handler (original)
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('fileName').textContent = `Selected: ${file.name}`;

            const reader = new FileReader();
            reader.onload = function(event) {
                processFile(event.target.result);
            };
            reader.onerror = function() {
                showError('Error reading file. Please try again.');
            };
            reader.readAsText(file);
        });

        // Drag and drop support (original)
        const uploadSection = document.querySelector('.upload-section');

        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#0066cc';
        });

        uploadSection.addEventListener('dragleave', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#4a4a4a';
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.style.borderColor = '#4a4a4a';

            const file = e.dataTransfer.files[0];
            if (file) {
                document.getElementById('fileInput').files = e.dataTransfer.files;
                document.getElementById('fileName').textContent = `Selected: ${file.name}`;

                const reader = new FileReader();
                reader.onload = function(event) {
                    processFile(event.target.result);
                };
                reader.readAsText(file);
            }
        });

        // ---- PATCH: wire controls ----
        const zSpanSlider = document.getElementById('zSpanSlider');
        const zSpanValue = document.getElementById('zSpanValue');

        function setVisualSpan(v) {
            // clamp 0.10..5.00
            const clamped = Math.max(0.10, Math.min(5.00, v));
            visualZSpan = clamped;
            zSpanSlider.value = String(clamped);
            zSpanValue.textContent = `${clamped.toFixed(2)} mm`;
        }

        // default 1.00 mm
        setVisualSpan(1.00);

        zSpanSlider.addEventListener('input', () => {
            setVisualSpan(parseFloat(zSpanSlider.value));
            rerenderIfReady();
        });

        document.getElementById('autoZBtn').addEventListener('click', () => {
            if (!currentMesh) return;
            const trueFlatness = computeFlatness(currentMesh.points);
            setVisualSpan(trueFlatness);
            rerenderIfReady();
        });

        // ✅ PATCH: reset view ALSO resets scaling to 1.00 mm
        document.getElementById('resetViewBtn').addEventListener('click', () => {
            Plotly.relayout('plotContainer', { 'scene.camera': FRONT_CAMERA });
            setVisualSpan(1.00);
            rerenderIfReady();
        });

        document.getElementById('exportCsvBtn').addEventListener('click', () => {
            if (!currentMesh) return;
            exportMeshCSV(currentMesh, currentMeshLabel || 'bed_mesh');
        });

        // ---- PATCH: saved mesh CRUD ----
        renderSavedDropdown(); // ✅ already auto-selects __last__ if any exist

        document.getElementById('saveMeshBtn').addEventListener('click', () => {
            if (!currentMesh) return;

            const stamp = new Date().toLocaleString();
            const base = currentMeshLabel || 'Mesh';
            const label = `${base} @ ${stamp}`;

            savedMeshes.push({
                label,
                saved_at: stamp,
                flatness: computeFlatness(currentMesh.points),
                mesh: JSON.parse(JSON.stringify(currentMesh))
            });

            persistSavedMeshes();
            renderSavedDropdown();
            rerenderIfReady(); // if delta reference is __last__
        });

        document.getElementById('loadMeshBtn').addEventListener('click', () => {
            const idx = getSelectedSavedIndex();
            if (idx === null || !savedMeshes[idx]) return;
            displaySavedMesh(savedMeshes[idx]);
        });

        document.getElementById('renameMeshBtn').addEventListener('click', () => {
            const idx = getSelectedSavedIndex();
            if (idx === null || !savedMeshes[idx]) return;

            const next = prompt('Rename saved mesh:', savedMeshes[idx].label);
            if (!next) return;

            savedMeshes[idx].label = next.trim();
            persistSavedMeshes();
            renderSavedDropdown();
            rerenderIfReady();
        });

        document.getElementById('deleteMeshBtn').addEventListener('click', () => {
            const idx = getSelectedSavedIndex();
            if (idx === null || !savedMeshes[idx]) return;

            if (!confirm(`Delete saved mesh?\n\n${savedMeshes[idx].label}`)) return;

            savedMeshes.splice(idx, 1);
            persistSavedMeshes();
            renderSavedDropdown();
            rerenderIfReady();
        });

        document.getElementById('clearAllBtn').addEventListener('click', () => {
            if (!confirm('Delete ALL saved meshes from this browser?')) return;
            savedMeshes = [];
            persistSavedMeshes();
            renderSavedDropdown();
            rerenderIfReady();
        });

        // ✅ PATCH: dropdown change auto-loads mesh (and also updates delta when choosing __last__/__none__)
        document.getElementById('savedMeshSelect').addEventListener('change', () => {
            const idx = getSelectedSavedIndex();

            if (idx !== null && savedMeshes[idx]) {
                // auto-load selected mesh
                displaySavedMesh(savedMeshes[idx]);
            } else {
                // just refresh delta card
                rerenderIfReady();
            }
        });
    </script>
</body>
</html>
